---
name: plan-review
description: 플랜 작성 후 Gemini CLI/Codex CLI를 활용한 외부 모델 교차 검토. 복잡한 플랜 리뷰, 아키텍처 결정 검토 시 사용.
---

# Plan Review - 외부 모델 교차 검토

## 1. 개요

플랜 작성 후 ExitPlanMode 전에 Gemini CLI와 Codex CLI에게 **구조화된 컨텍스트**와 함께 플랜을 전달하여 교차 검토를 수행합니다.

### 핵심 원칙
- 플랜 텍스트만 보내지 않음 → **구조화된 컨텍스트** 포함
- 각 모델에 **다른 관점**의 리뷰를 요청 (역할 분리)
- 리뷰 결과는 **1회만 반영** (무한 루프 방지)
- CLI 미설치 시 해당 리뷰는 생략

## 2. 사용 시점

| 상황 | 사용 여부 |
|------|----------|
| 3개 이상 파일 수정 플랜 | 권장 |
| 아키텍처 결정 포함 | 권장 |
| 새 모듈/서비스 추가 | 권장 |
| 사용자가 `/review-plan` 호출 | 필수 |
| 단일 파일 수정 | 불필요 |
| 단순 버그 수정 | 불필요 |

## 3. 워크플로우

```
플랜 작성 완료
    │
    ▼
Step 1: 구조화된 컨텍스트 생성
    │   → /tmp/plan_review_context.md 작성
    │
    ▼
Step 2: 리뷰 스크립트 실행 (병렬)
    │   → Gemini CLI (구조/아키텍처 리뷰)
    │   → Codex CLI (실행가능성/정밀 리뷰)
    │
    ▼
Step 3: 결과 통합
    │   → /tmp/plan_review_result.md 읽기
    │   → 유효한 지적사항만 필터링
    │
    ▼
Step 4: 플랜 수정 (필요 시, 최대 1회)
    │
    ▼
ExitPlanMode
```

## 4. Step 1: 구조화된 컨텍스트 생성

다음 내용을 `/tmp/plan_review_context.md`에 작성합니다:

```markdown
# 플랜 검토 요청

## 사용자 원래 요청
[사용자가 처음 요청한 내용을 1-3문장으로 요약]

## 프로젝트 제약 조건
- 기술 스택: [예: FastAPI + Next.js + LangGraph]
- 아키텍처: [예: 모듈형, backend/app/modules/ 자동 등록]
- 기존 패턴: [예: snake_case API, Pydantic 스키마, feature flag]
- 특별 제약: [예: JSON 서비스 파일 삭제 금지, 롤백 보장 필수]

## 수정 대상 파일
- `path/to/file1.py` - 변경 내용 요약
- `path/to/file2.tsx` - 변경 내용 요약

## 현재 관련 코드 구조
[수정 대상 파일의 현재 구조를 간략히 기술. 인터페이스/시그니처 수준]

## 검토 대상 플랜
[플랜 전문을 그대로 포함]
```

### 컨텍스트 생성 규칙
- 전체 대화를 복사하지 않음 (핵심만 요약)
- 코드 전문이 아닌 **구조/인터페이스** 수준으로 기술
- 민감 정보 (.env, API 키) 절대 포함 금지
- 컨텍스트 부분(플랜 제외) 길이: 2,000자 이내 권장

## 5. Step 2: 외부 모델 리뷰 실행

### 방법 A: 리뷰 스크립트 사용 (권장)

```bash
bash "$CLAUDE_PROJECT_DIR/.claude/hooks/review-plan.sh" /tmp/plan_review_context.md
```

스크립트가 Gemini CLI + Codex CLI를 **병렬**로 호출하고 결과를 `/tmp/plan_review_result.md`에 저장합니다.

### 방법 B: 수동 실행 (스크립트 실패 시 Fallback)

**Gemini CLI** (구조/아키텍처 관점):
```bash
gemini "당신은 소프트웨어 아키텍트입니다. 다음 구현 플랜을 검토해주세요.

검토 관점:
1. 기존 아키텍처와의 일관성
2. 누락된 파일/의존성/영향 범위
3. 모듈 간 결합도 문제
4. 확장성/유지보수성 우려

형식: [통과/주의/문제] 판정 + 1줄 근거. 문제 없으면 '검토 통과'.

---
$(cat /tmp/plan_review_context.md)
---" -y -o text
```

**Codex CLI** (실행가능성/정밀성 관점):
```bash
codex --full-auto "당신은 시니어 개발자입니다. 다음 구현 플랜의 실행가능성을 검토해주세요.

검토 관점:
1. 구현 순서의 논리적 정확성
2. 타입/인터페이스 호환성 (Backend↔Frontend)
3. 엣지 케이스 누락
4. 테스트 전략의 충분성

형식: [통과/주의/문제] 판정 + 1줄 근거. 문제 없으면 '검토 통과'.

---
$(cat /tmp/plan_review_context.md)
---"
```

## 6. Step 3: 결과 통합

### 결과 판정 기준

| 판정 | 조치 |
|------|------|
| 양쪽 모두 "검토 통과" | 플랜 수정 없이 ExitPlanMode |
| [주의] 항목만 있음 | 사용자에게 주의사항 보고, 수정은 선택적 |
| [문제] 항목이 있음 | 실제 코드 확인 후 유효하면 플랜 수정 |
| 양쪽이 모순된 의견 | 실제 코드를 기준으로 Claude가 판단 |

### 오탐 검증 (필수)

외부 모델이 지적한 내용은 반드시 검증:
- **파일 경로**: Glob/Read로 실제 존재 확인
- **함수/클래스**: Grep으로 실제 존재 확인
- **패턴/규칙**: 프로젝트 CLAUDE.md, rules/ 기준으로 확인

존재하지 않는 파일이나 함수를 근거로 한 지적은 오탐으로 판정하고 무시합니다.

## 7. Step 4: 플랜 수정 (최대 1회)

### 무한 루프 방지

- 외부 리뷰 → 플랜 수정은 **최대 1회**만 수행
- 수정 후 재리뷰는 하지 않음
- 수정이 필요하면 수정 내용을 사용자에게 보고

### 사용자 보고 형식

```
## 외부 모델 리뷰 결과

### Gemini CLI (구조/아키텍처)
- [통과] 아키텍처 일관성
- [주의] XXX에 대한 영향 범위 추가 필요

### Codex CLI (실행가능성)
- [통과] 구현 순서
- [문제] YYY 타입 불일치 → 플랜 수정 반영

### 플랜 수정 사항
- ZZZ 단계를 추가함 (Codex 지적 반영)
```

## 8. CLI 미설치 시 처리

| 상황 | 처리 |
|------|------|
| Gemini + Codex 모두 설치 | 양쪽 병렬 리뷰 |
| Gemini만 설치 | Gemini 리뷰만 실행 |
| Codex만 설치 | Codex 리뷰만 실행 |
| 둘 다 미설치 | 리뷰 생략, 사용자에게 안내 |

## 9. 역할 분리 근거

| 모델 | 강점 | 리뷰 관점 |
|------|------|----------|
| **Gemini** | 1M 토큰 컨텍스트, 구조 파악 | 아키텍처 일관성, 누락된 영향 범위 |
| **Codex** | 정밀 추론, 코드 리뷰 특화 | 구현 순서, 타입 호환성, 엣지 케이스 |

같은 관점을 중복 요청하지 않고, 각 모델의 강점에 맞는 리뷰를 요청합니다.

## 10. 금지 사항

- 민감 정보를 컨텍스트에 포함
- 리뷰 결과를 검증 없이 반영
- 2회 이상 리뷰-수정 반복 (무한 루프)
- 단순 플랜에 불필요한 리뷰 실행
- 외부 모델에 코드 수정 요청 (리뷰만 요청)
